# En R se utiliza preferentemente el operador <- (ALT + Guión (-)).
# Aunque el signo = también funciona, <- es la norma de estilo en R.
# Estructura => nombre_variable <- valor_variable
mi_numero=25 # sin espacios
## ¿Cómo se que se ha creado una variable? -> Comprobar el Environment
# Una vez ejecutas la línea de asignación, la variable aparecerá en la pestaña
# "Environment" (Entorno) de RStudio (panel superior derecho).
# Si modifico la variable es como si la eliminase y la crease de nuevo
mi_numero <- 24
# Para conocer su valor simplemente la ejecutamos
mi_numero
?mean # se abre la ayuda de la función mean.
sqrt(10) # calcula la raíz cuadrada de 10
sqrt(c(10, 20)) # calcula la raíz cuadrada de 10 y 20
# La función mean(), que se utiliza para calcular la media de un vector de números es una función de agregación.
# Devuelve solo un valor.
mean(c(10, 20)) # Devuelve la media de 10 y 20
?log # función para calcular logaritmos
EXP(1)
exp(1)
### Aplicadas a vectores
vector_numeros <- c(50, 10, 20, 30, 30)
vector_texto <- c("Hola","Mundo",NA)
## length() -> length(vector) -> devuelve la longitud del vector
length(vector_numeros)
## is.na() -> is.na(vector) -> devuelve un vector lógico indicando las posiciones que tienen un NA
is.na(vector_texto)
## na.omit() -> na.omit(vector) -> devuelve el vector original eliminando los NA
na.omit(vector_texto)
## unique() -> unique(vector) -> devuelve un vector con los elementos únicos de un vector
unique(vector_numeros)
## rank() -> rank(vector, ties.method = "average") -> genera un vector con la posición de los valores de otro vector de menor a mayor
# En caso de empate aplica el ties.method = average (media)
vector_numeros
rank(vector_numeros)
rank(vector_numeros, ties.method = "first") # en caso de empate coge el primero
## rev() -> rev(vector) -> invierte el orden de un vector
vector_texto
rev(vector_texto)
### Generar Vectores
## rep() -> rep(atómico o vector, times) -> crea elementos repetidos tantas veces como se indique (times)
rep(5, times = 10)
### Generar Vectores
## rep() -> rep(atómico o vector, times) -> crea elementos repetidos tantas veces como se indique (times)
rep(5, times = 10)
rep(vector_numeros, 2)
### Unificar datos
## paste() -> paste(vector o conjunto de elementos, collapse = NULL, sep = " ")
paste("Mi número es", mi_numero) # funcionalidad general, sep = " "
paste("Mi número es", mi_numero, "que dividido entre 4 es", mi_numero/4) # funcionalidad general, sep = " "
paste("Mi número es", mi_numero, sep = "-") # ahora en vez de usar espacios usa "-"
paste("Mi número es ", mi_numero, sep = "") # ahora en vez de usar espacios usa ""
paste("Mi número es", mi_numero, sep = "") # ahora en vez de usar espacios usa ""
# Uso en vectores
paste("Mi número es", vector_numeros) # se aplica a cada elemento del vector
# Collapsar un vector
paste(vector_numeros, collapse = ", ") # usando el argumento collapse indicamos como queremos colapsar los elementos del vector
paste("Mis números son", paste(vector_numeros, collapse = ", ")) # como se usaría de forma inteligente
expression <- matrix(rnorm(1000), nrow = 100, ncol = 10)
colnames(expression) <- paste("Patient",1:10, sep = "_")
expression <- matrix(rnorm(1000), nrow = 100, ncol = 10)
colnames(expression) <- paste("Patient",1:10, sep = "_")
rownames(expression) <- paste("Gene",1:100, sep = "_")
expression
head(expression)
# Hay varios métodos de hacer esto, el que aprenderemos aquí es usando la función pivot_longer
library(tidyverse)
expression_tidy <- expression %>%
as.data.frame() %>% # lo transformamos a dataframe
rownames_to_column("Gene") %>% # Crea una nueva columna Gene con los valores de los rownames
# cols = colnames(expression) -> transforma a filas las columnas de expression
# names_to = "Patient" -> asigna los diferentes valores de las columnas a la columna "Patient"
# values_to = "Value" -> asigna los valores de la matriz a la columna Value
pivot_longer(cols = colnames(expression), names_to = "Patient", values_to = "Value")
View(expression_tidy)
head(expression_tidy)
## Para transformar una tabla de tidy a wide (matrix) usamos la función pivot_wide
expression_wide <- expression_tidy %>%
pivot_wider()
## Para transformar una tabla de tidy a wide (matrix) usamos la función pivot_wide
expression_wide <- expression_tidy %>%
pivot_wider(names_from = "Patient")
## Para transformar una tabla de tidy a wide (matrix) usamos la función pivot_wide
expression_wide <- expression_tidy %>%
pivot_wider(names_from = "Patient", values_from = "Value")
View(expression_wide)
## Para transformar una tabla de tidy a wide (matrix) usamos la función pivot_wide
expression_wide <- expression_tidy %>%
# Al revés que pivot longer, ahora indicamos que columna queremos transformar a columnas
pivot_wider(names_from = "Patient", values_from = "Value") %>%
column_to_rownames("Gene")
View(expression_wide)
tabla_pacientes <- data.frame(id =  paste("Patient",1:10, sep = "_"),
group = rep(c("Caso", "Control"), 5))
tabla_pacientes <- data.frame(id =  paste("Patient",1:10, sep = "_"),
group = rep(c("Caso", "Control"), 5),
imc = runif(10, 20, 30))
View(tabla_pacientes)
tabla_pacientes
# left_join() -> une la tabla de la derecha a la tabla de la izquierda
expression_tidy_join <- expression_tidy %>%
left_join(tabla_pacientes, by =c("Patient" = "id"))
View(expression_tidy_join)
nutrients <- data.frame(Treatment = c(rep(1, 3), rep(2, 3)))
View(nutrients)
nutrients <- data.frame(Treatment = c(rep(1, 3), rep(2, 3)),
Replicate = rep(c(1, 2, 3), 2))
View(nutrients)
nutrients <- data.frame(Treatment = c(rep(1, 3), rep(2, 3)),
Replicate = rep(c(1, 2, 3), 2),
Amonium = rnorm(6, mean = 10))
View(nutrients)
nutrients <- data.frame(Treatment = c(rep(1, 3), rep(2, 3)),
Replicate = rep(c(1, 2, 3), 2),
Amonium = rnorm(6, mean = 10),
Nitrate = rnorm(6, mean = 3))
carbon <- data.frame(Treatment = c(rep(1, 3), rep(2, 3), rep(3, 3)),
Replicate = rep(c(1, 2, 3), 3))
View(carbon)
carbon <- data.frame(
Treatment = c(rep(1, 2), rep(2, 3), rep(3, 3)),
Replicate = c(1, 3, rep(c(1, 2, 3), 2)),
Carbon = rnorm(8, mean = 40)
)
View(carbon)
nutrients <- data.frame(Treatment = c(rep(1, 3), rep(2, 3)),
Replicate = rep(c(1, 2, 3), 2),
Amonium = rnorm(6, mean = 10),
Nitrate = rnorm(6, mean = 3))
carbon <- data.frame(
Treatment = c(rep(1, 2), rep(2, 3), rep(3, 3)),
Replicate = c(1, 3, rep(c(1, 2, 3), 2)),
Carbon = rnorm(8, mean = 40)
)
nutrients
carbon
nutrients %>%
left_join(carbon, by = c("Treatment", "Replicate"))
## tidyverse nos permite usar un enfoque más moderno e intuitivo
# instalar y cargar librería
# install.packages("tidyverse")
library(tidyverse)
# Usaremos estos datframes como ejemplo
clients = read.csv("https://github.com/anderfernandez/datasets/blob/main/telcom-support/clients.csv")
clients
# Usaremos estos datframes como ejemplo
clients = read_csv("https://github.com/anderfernandez/datasets/blob/main/telcom-support/clients.csv")
# Usaremos estos datframes como ejemplo
clients = read.csv("https://github.com/anderfernandez/datasets/blob/main/telcom-support/clients.csv", sep = ",")
View(clients)
# Usaremos estos datframes como ejemplo
clients = read.csv("https://github.com/anderfernandez/datasets/raw/refs/heads/main/telcom-support/clients.csv", sep = ",")
View(clients)
clients
head(clients)
# Usaremos estos datframes como ejemplo
clients = read.csv("https://github.com/anderfernandez/datasets/raw/refs/heads/main/telcom-support/clients.csv")
head(clients)
orders = read.csv("https://github.com/anderfernandez/datasets/raw/refs/heads/main/telcom-support/orders.csv")
orders
# Usaremos estos dataframes como ejemplo
clients = read.csv("https://github.com/anderfernandez/datasets/raw/refs/heads/main/telcom-support/clients.csv")
head(clients)
orders = read.csv("https://github.com/anderfernandez/datasets/raw/refs/heads/main/telcom-support/orders.csv")
head(orders)
# USOS
# 1. Seleccionar o descartar columnas
# 1.1. Indicando las que queremos
clients %>%
select(num_client, job)
clients %>%
select(any_of(columns))
# 1.3. Seleccionar las columnas en base a un vector
columns <- c("num_client", "job")
clients %>%
select(any_of(columns))
clients %>%
select(-any_of(columns)) # any_of devuelve las que columnas que estén en el dataframe
# 2. Renombrar columnas
# 2.1 Seleccionamos la columna que hemos renombrado
clients %>%
select(num_client = client_id) # seleccionamos la columna name pero además le cambiamos el nombre
# 2. Renombrar columnas
# 2.1 Seleccionamos la columna que hemos renombrado
clients %>%
select(client_id = num_client) # seleccionamos la columna name pero además le cambiamos el nombre
# 2.2 Seleccionamos la columna que hemos renombrado y las demás (everything())
clients %>%
select(client_id = num_client, everything()) # con everything() seleccionamos todas las columnas, incluida la renombrada
# USOS
# 1. Filtros con operadores lógicos
clients %>%
filter(age > 20)
clients %>%
filter(age > 20 & fidelity_points > 500)
# 2. filtrar de un vector externo
num_clients <- 1:10
clients %>%
filter(num_client %in% num_clients)
# 2. filtrar de un vector externo
num_clients <- 1:10
clients %>%
filter(num_client %in% num_clients)
clients %>%
filter(!num_client %in% num_clients)
# 3. Filtrar valores faltantes (NA)
clients %>%
filter(!is.na(age))
View(orders)
expresion <- matrix(rnorm(12000), ncol = 10, nrow = 120)
expresion <- matrix(rnorm(12000), ncol = 10, nrow = 1200)
expresion <- matrix(rnorm(12000), ncol = 10, nrow = 1200)
colnames(expresion) <- paste("Individuo", 1:10, sep = "_")
rownames(expresion) <- paste("Gen", 1:1200, sep = "_")
set.seed()
set.seed(123456789)
expresion <- matrix(rnorm(12000), ncol = 10, nrow = 1200)
colnames(expresion) <- paste("Individuo", 1:10, sep = "_")
rownames(expresion) <- paste("Gen", 1:1200, sep = "_")
metadata <- data.frame(ID = paste("Individuo", 1:10, sep = "_"),
Grupo = rep(c("Caso", "Control"), 5))
View(metadata)
metadata <- data.frame(ID = paste("Individuo", 1:10, sep = "_"),
Grupo = rep(c("Caso", "Control"), 5),
Peso = sample(60:100, size = 10, replace = TRUE),
Altura = round(runif(10, min = 160, max = 190)))
View(metadata)
set.seed(123456789)
expresion <- matrix(rnorm(120000), ncol = 100, nrow = 1200)
colnames(expresion) <- paste("Individuo", 1:100, sep = "_")
rownames(expresion) <- paste("Gen", 1:1200, sep = "_")
metadata <- data.frame(ID = paste("Individuo", 1:100, sep = "_"),
Grupo = rep(c("Caso", "Control"), 50),
Peso = sample(60:100, size = 100, replace = TRUE),
Altura = round(runif(100, min = 160, max = 190)),
Genero = sample(c("Hombre","Mujer"), size = 100, replace = TRUE))
View(metadata)
metadata <- data.frame(ID = paste("Individuo", 1:100, sep = "_"),
Grupo = sample(c("Caso_1", "Caso_2","Control"), size = 100, replace = TRUE),
Peso = sample(60:100, size = 100, replace = TRUE),
Altura = round(runif(100, min = 160, max = 190)),
Genero = sample(c("Hombre","Mujer"), size = 100, replace = TRUE))
set.seed(123456789)
expresion <- matrix(rnorm(120000), ncol = 100, nrow = 1200)
colnames(expresion) <- paste("Individuo", 1:100, sep = "_")
rownames(expresion) <- paste("Gen", 1:1200, sep = "_")
metadata <- data.frame(ID = paste("Individuo", 1:100, sep = "_"),
Grupo = sample(c("Caso_1", "Caso_2","Control"), size = 100, replace = TRUE),
Peso = sample(60:100, size = 100, replace = TRUE),
Altura = round(runif(100, min = 160, max = 190)),
Genero = sample(c("Hombre","Mujer"), size = 100, replace = TRUE))
set.seed(123456789)
expresion <- matrix(rnorm(120000), ncol = 100, nrow = 1200)
colnames(expresion) <- paste("Individuo", 1:100, sep = "_")
rownames(expresion) <- paste("Gen", 1:1200, sep = "_")
expresion <- as.data.frame(expresion)
metadata <- data.frame(ID = paste("Individuo", 1:100, sep = "_"),
Grupo = sample(c("Caso_1", "Caso_2","Control"), size = 100, replace = TRUE),
Peso = sample(60:100, size = 100, replace = TRUE),
Altura = round(runif(100, min = 160, max = 190)),
Genero = sample(c("Hombre","Mujer"), size = 100, replace = TRUE))
# USOS
# 1. Seleccionar o descartar columnas
# 1.1. Indicando las que queremos
metadata %>%
select(Genero, Altura)
set.seed(123456789)
expresion <- matrix(rnorm(120000), ncol = 100, nrow = 1200)
colnames(expresion) <- paste("Individuo", 1:100, sep = "_")
rownames(expresion) <- paste("Gen", 1:1200, sep = "_")
expresion <- as.tibble(expresion)
metadata <- as.tibble(data.frame(ID = paste("Individuo", 1:100, sep = "_"),
Grupo = sample(c("Caso_1", "Caso_2","Control"), size = 100, replace = TRUE),
Peso = sample(60:100, size = 100, replace = TRUE),
Altura = round(runif(100, min = 160, max = 190)),
Genero = sample(c("Hombre","Mujer"), size = 100, replace = TRUE)))
set.seed(123456789)
expresion <- matrix(rnorm(120000), ncol = 100, nrow = 1200)
colnames(expresion) <- paste("Individuo", 1:100, sep = "_")
rownames(expresion) <- paste("Gen", 1:1200, sep = "_")
expresion <- as_tibble(expresion)
metadata <- as_tibble(data.frame(ID = paste("Individuo", 1:100, sep = "_"),
Grupo = sample(c("Caso_1", "Caso_2","Control"), size = 100, replace = TRUE),
Peso = sample(60:100, size = 100, replace = TRUE),
Altura = round(runif(100, min = 160, max = 190)),
Genero = sample(c("Hombre","Mujer"), size = 100, replace = TRUE)))
# USOS
# 1. Seleccionar o descartar columnas
# 1.1. Indicando las que queremos
metadata %>%
select(Genero, Altura)
expresion %>%
select(Individuo_1, Individuo_6)
set.seed(123456789)
expresion <- matrix(rnorm(120000), ncol = 100, nrow = 1200)
colnames(expresion) <- paste("Individuo", 1:100, sep = "_")
rownames(expresion) <- paste("Gen", 1:1200, sep = "_")
expresion <- as.data.frame(expresion)
expresion %>%
select(Individuo_1, Individuo_6)
# Para este ejemplo, imaginemos que filtramos filas donde NO haya NAs en Altura
metadata$Altura[c(1, 10, 15)] <- NA
metadata %>%
filter(!is.na(Altura))
# 1.1. Ver qué valores únicos existen en una columna
metadata %>%
distinct(Grupo) # Nos muestra las 3 categorías: Caso_1, Caso_2 y Control
## distinct() -> Para eliminar filas duplicadas o ver valores únicos
# anatomía: datos %>% distinct(columna1, .keep_all = TRUE)
starwars %>%
distinct(homeworld)
# 1.2. Eliminar duplicados manteniendo el resto de columnas
# Por defecto, distinct() solo devuelve las columnas que mencionas.
# Usa .keep_all = TRUE para no perder el resto de la información.
metadata %>%
distinct(Genero, Grupo, .keep_all = TRUE) # Primera combinación única de Género/Grupo que encuentra
### slice() -> Para seleccionar filas por su posición
# anatomía: datos %>% slice(posiciones)
starwars %>%
slice(1:10)
### 4. Ejemplo final combinado
# Queremos los 3 individuos más pesados de los grupos "Caso", ordenados por altura.
metadata_top <- metadata %>%
filter(Grupo %in% c("Caso_1", "Caso_2")) %>% # Filtramos grupos que contienen la palabra "Caso"
slice_max(order_by = Peso, n = 3) %>%
arrange(desc(Altura))
# Visualizamos
print(metadata_top)
# 1. Agrupación simple
# Agrupamos por el tipo de Caso/Control
metadata %>%
group_by(Grupo)
# 2. Agrupación múltiple
# Podemos agrupar por varias categorías a la vez (ej. Grupo y Genero)
metadata %>%
group_by(Grupo, Genero)
# 3. Ejemplo de flujo de agrupación
metadata_agrupado <- metadata %>%
group_by(Grupo)
metadata_desagrupado <- metadata_agrupado %>%
ungroup()
## group_by() -> Para agrupar los datos por una o más variables
# anatomía: datos %>% group_by(columna1, columna2, ...)
# Al ejecutarlo, verás que arriba del tibble pone "Groups: Columna [N]"
starwars %>%
group_by(homeworld)
## group_by() -> Para agrupar los datos por una o más variables
# anatomía: datos %>% group_by(columna1, columna2, ...)
# Al ejecutarlo, verás que arriba del tibble pone "Groups: Columna [N]"
starwars %>%
group_by(gender)
### 1. mutate() -> Para crear nuevas columnas o transformar las existentes
# anatomía: datos %>% mutate(nombre_nueva_columna = operación)
starwars %>%
mutate(species_mayuscula = toupper(species))
# 2. Usando varias columnas: Calcular el Índice de Masa Corporal (IMC)
# Fórmula: peso / (altura^2)
metadata %>%
mutate(IMC = Peso / (Altura/100)^2)
# 3. Modificar el valor de una columna existente
metadata %>%
mutate(Altura = round(Altura / 100, 2))
# Modificar la columna Genero para que sea un factor
metadata %>%
mutate(Genero = factor(Genero))
# Vamos a usar el dataframe 'expresion' que creaste al principio.
# Pasaremos los individuos de columnas a una sola columna de "Muestra"
individuos <- colnames(expresion)
expresion_larga <- expresion %>%
rownames_to_column(var = "Gen") %>% # Convertimos los nombres de filas en una columna
pivot_longer(cols = all_of(individuos),
names_to = "Muestra",
values_to = "Expresion_Valor")
View(expresion_larga)
head(expresion_larga)
# 2. Con agrupación (group_by): Resumen por categorías
# Este es el uso más común en análisis de datos
resumen_por_grupo <- metadata %>%
group_by(Grupo) %>%
summarise(Media_Peso = mean(Peso),
SD_Peso = sd(Peso),
Muestras = n()) %>%
ungroup()
# 2. Con agrupación (group_by): Resumen por categorías
# Este es el uso más común en análisis de datos
metadata %>%
group_by(Grupo) %>%
summarise(Media_Peso = mean(Peso),
SD_Peso = sd(Peso),
Muestras = n()) %>%
ungroup()
metadata %>%
group_by(Grupo, Genero) %>%
summarise(Media_Peso = mean(Peso),
SD_Peso = sd(Peso),
Muestras = n()) %>%
ungroup()
# Calcular la media de todas las columnas numéricas por Género
metadata %>%
group_by(Genero) %>%
summarise(across(where(is.numeric), mean, na.rm = TRUE))
# Calcular la media de todas las columnas numéricas por Género
metadata %>%
group_by(Genero) %>%
summarise(
# altura
altura_mean = mean(Altura),
altura_max = max(Altura),
altura_min = min(Altura),
# peso
peso_mean = mean(peso),
peso_max = max(peso),
peso_min = min(peso),
)
# Calcular la media de todas las columnas numéricas por Género
metadata %>%
group_by(Genero) %>%
summarise(
# altura
altura_mean = mean(Altura),
altura_max = max(Altura),
altura_min = min(Altura),
# peso
peso_mean = mean(Peso),
peso_max = max(Peso),
peso_min = min(Peso),
)
# Calcular la media de todas las columnas numéricas por Género
metadata %>%
group_by(Genero) %>%
summarise(
# altura
altura_mean = mean(Altura, na.rm = TRUE),
altura_max = max(Altura, na.rm = TRUE),
altura_min = min(Altura, na.rm = TRUE),
# peso
peso_mean = mean(Peso, na.rm = TRUE),
peso_max = max(Peso, na.rm = TRUE),
peso_min = min(Peso, na.rm = TRUE),
)
metadata %>%
group_by(Genero) %>%
summarise(across(
c(Altura, Peso), # Variables a calcular
list(mean, max, min) # funciones a aplicar
))
metadata %>%
group_by(Genero) %>%
summarise(across(
c(Altura, Peso), # Variables a calcular
list(  # funciones a aplicar
media = ~mean(., na.rm = TRUE), # indicar los parámetros de cada función
maximo = ~max(., na.rm = TRUE),
minimo = ~min(., na.rm = TRUE)
)
))
# ¿Cuántos individuos hay en cada combinación de Grupo y Género?
metadata %>%
count(Grupo, Genero)
# 1.1. bind_rows() -> Pega una tabla debajo de otra
# Útil si tienes datos de pacientes nuevos y quieres añadirlos al final.
nuevos_individuos <- tibble(
ID = c("Individuo_101", "Individuo_102"),
Grupo = c("Caso_1", "Control"),
Peso = c(75, 82),
Altura = c(170, 185),
Genero = c("Mujer", "Hombre")
)
metadata_extendida <- bind_rows(metadata, nuevos_individuos)
bind_rows(metadata, nuevos_individuos)
bind_rows(metadata, nuevos_individuos) %>% slice_tail(1:10)
bind_rows(metadata, nuevos_individuos) %>% slice_tail(n = 1:10)
bind_rows(metadata, nuevos_individuos) %>% slice_tail(n = 10)
bind_cols(metadata, datos_extras)
# 1.2. bind_cols() -> Pega una tabla al lado de otra
# ¡CUIDADO! Solo úsalo si estás 100% seguro de que las filas están en el mismo orden.
datos_extras <- tibble(
Ciudad = rep("Sevilla", 100),
Fumador = sample(c("Sí", "No"), 100, replace = TRUE)
)
bind_cols(metadata, datos_extras)
# 2.1. left_join(x, y) -> Mantiene todo lo de la izquierda (x) y añade lo que encuentre en la derecha (y).
# Es el más usado. Si no hay coincidencia, rellena con NA.
dieta_info <- tibble(
ID = c("Individuo_1", "Individuo_2", "Individuo_3"),
Dieta = c("Keto", "Mediterránea", "Vegana")
)
metadata %>%
left_join(dieta_info, by = "ID")
# 2.2. inner_join(x, y) -> Solo mantiene las filas que tienen coincidencia en AMBAS tablas.
metadata %>%
inner_join(dieta_info, by = "ID") # Solo devolvería 3 filas
# 2.3. full_join(x, y) -> Mantiene TODAS las filas de ambas tablas, coincidan o no.
metadata %>%
full_join(dieta_info, by = "ID")
# 2.4. anti_join(x, y) -> Filtra y te da lo que NO está en la segunda tabla.
# Útil para ver qué pacientes NO tienen datos de dieta.
metadata %>%
anti_join(dieta_info, by = "ID")
# 3. Ejemplo final combinado
# Vamos a unir la expresión del Gen_1 con los metadatos de los pacientes.
expresion_gen1 <- expresion %>%
rownames_to_column(var = "Gen") %>%
filter(Gen == "Gen_1") %>%
pivot_longer(-Gen, names_to = "ID", values_to = "Nivel")
View(expresion_gen1)
data_final <- metadata %>%
inner_join(expresion_gen1, by = "ID") %>%
select(ID, Grupo, Nivel) %>%
arrange(desc(Nivel))
View(data_final)
View(data_final)
