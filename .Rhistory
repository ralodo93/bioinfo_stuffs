# Saludo básico en R
print("Hola Mundo") # Imprimir mensaje por consola
print(5)
# Calculadora
8+7 # Sumar 8 y 7
8*10 # Multiplicar 8 por 10
20/5 # Dividir 20 entre 5
8^2 # Elevar 8 al cuadrado
# Variables
# Es un nombre (una etiqueta) donde guardas un valor para usarlo después.
a = 7 # Asignar valor 7 a la variable a
print(a)
print(a)
b <- 8 # Asignar valor 8 a la variable b
a + b # Sumar a y b
## Variables numéricas
x <- 10.5 # Asignar valor 10.5 a la variable x
y <- 85*4 # Asignar el resultado de 85 por 4 a la variable y
z <- x + y # Asignar el resultado de x más y a la variable z
print(z)
## Variables de texto
nombre <- "Juan" # Asignar el texto "Juan" a la variable nombre
## Variables de texto
nombre <- juan
## Variables de texto
nombre <- "Juan" # Asignar el texto "Juan" a la variable nombre
apellido <- "Pérez" # Asignar el texto "Pérez" a la variable apellido
nombre_completo <- paste(nombre, apellido) # Concatenar nombre y apellido
print(nombre_completo)
## Variables lógicas (Booleanas)
# Solo pueden tener dos valores: TRUE (Verdadero) o FALSE (Falso)
es_mayor <- TRUE
es_menor <- FALSE
# Se suelen generar al comparar valores (operadores lógicos)
10 > 5   # ¿Es 10 mayor que 5? Resultado: TRUE
# Se suelen generar al comparar valores (operadores lógicos)
A=10 > 5   # ¿Es 10 mayor que 5? Resultado: TRUE
10 == 10 # ¿Es 10 igual a 10? Resultado: TRUE (Ojo: doble igual para comparar)
8 != 10 # ¿Es 8 diferente a 10? Resultado: TRUE
# Ejemplo práctico: ¿Tiene el paciente una edad mayor a 30?
edad <- 35
resultado_chequeo <- edad > 30
print(resultado_chequeo) # Imprimirá TRUE
## Vectores
# Una colección de elementos que tienen que ser del mismo tipo (todos números o todos texto). Ej. Una columna de excel
a <- c(1,2,3,4,5) # Crear un vector a con los valores del 1 al 5
a=8
## Vectores
# Una colección de elementos que tienen que ser del mismo tipo (todos números o todos texto). Ej. Una columna de excel
a <- c(1,2,3,4,5) # Crear un vector a con los valores del 1 al 5
a[1] # Acceder al primer elemento del vector a
a[3] # Acceder al tercer elemento del vector a
a[1] # Acceder al primer elemento del vector a
## Vectores
# Una colección de elementos que tienen que ser del mismo tipo (todos números o todos texto). Ej. Una columna de excel
a <- c(8,2,3,4,5) # Crear un vector a
a[1] # Acceder al primer elemento del vector a
a[3] # Acceder al tercer elemento del vector a
## Vectores
# Una colección de elementos que tienen que ser del mismo tipo (todos números o todos texto). Ej. Una columna de excel
a <- c(1,2,3,4,5) # Crear un vector a con los valores del 1 al 5
a[1] # Acceder al primer elemento del vector a
a[3] # Acceder al tercer elemento del vector a
a[c(2,4)] # Acceder al segundo y cuarto elemento del vector a
## Vectores
# Una colección de elementos que tienen que ser del mismo tipo (todos números o todos texto). Ej. Una columna de excel
a <- c(10,20,30,40,50) # Crear un vector a con los valores del 1 al 5
a[1] # Acceder al primer elemento del vector a
a[3] # Acceder al tercer elemento del vector a
a[c(2,4)] # Acceder al segundo y cuarto elemento del vector a
a[c(5)]
length(a) # Obtener la longitud del vector a
a*2 # Multiplicar cada elemento del vector a por 2
b <- c(10,20,30,40,50) # Crear un vector b
b <- c(11,22,33,44,55) # Crear un vector b
b <- c(11,22,33,44,55) # Crear un vector b
a + b # Sumar los vectores a y b elemento por elemento
b <- c("Pérez", "Gómez", "Rodríguez") # Crear un vector de apellidos
a <- c("Juan", "María", "Luis") # Crear un vector de nombres
b <- c("Pérez", "Gómez", "Rodríguez") # Crear un vector de apellidos
nombres_completos <- paste(a, b) # Concatenar los vectores de
print(nombres_completos) # Imprimir los nombres completos
vector_TF <- c(TRUE, FALSE, TRUE, TRUE) # Crear un vector lógico
vector_TF[2] # Acceder al segundo elemento del vector lógico
a[a == "Juan"]
a == "Juan"
a == "Juan"
a == "Juan"
a == "Juan"
a[a == "Juan"]
b[b != "Rodríguez"]
b != "Rodríguez"
1:10
### Secuencias rápidas
# El operador : crea una secuencia de números del inicio al fin
numeros <- 1:10 # Crea un vector del 1 al 10 IMPORTANTE: No usar tildes, ñ, espacios ni caracteres especiales en los nombres de variables
print(numeros)
# También funciona en sentido inverso
cuenta_atras <- 10:1
print(cuenta_atras)
# Muy útil para acceder a rangos en un vector o data frame
a <- c("A", "B", "C", "D", "E")
1:3
a[1:3] # Acceder de la posición 1 a la 3
## Matrices
# Como un vector, pero organizado en dos dimensiones (filas y columnas). Al igual que los vectores, todos sus elementos deben ser del mismo tipo.
m <- matrix(1:9, nrow=3, ncol=3) # Crear una matriz de 3x3 con los números del 1 al 9
print(m)
m[1,2] # Acceder al elemento en la fila 1, columna 2
m[3,1] # Acceder al elemento en la fila 3, columna 1
m[2,] # Acceder a la fila 2 completa
m[,3] # Acceder a la columna 3 completa
m * 2
n <- matrix(9:1, nrow=3, ncol=3) # Crear otra matriz de 3x3 con los números del 9 al 1
m + n # Sumar las dos matrices elemento por elemento
t(m) # Calcular la transpuesta de la matriz m
print(m) # Imprimir la matriz
t(m) # Calcular la transpuesta de la matriz m
print(m) # Imprimir la matriz
1:2
print(m) # Imprimir la matriz
1:2
m[,1:2]
## Data Frames
# Es la estructura tipo "tabla de Excel". A diferencia de la matriz, cada columna puede tener un tipo de dato distinto (una columna de nombres y otra de edades)
df <- data.frame(
Nombre = c("Ana", "Luis", "Marta", "Jorge", "Sofía"), # coma
Edad = c(28, 34, 23, 45, 30),
Ciudad = c("Madrid", "Barcelona", "Valencia", "Sevilla", "Bilbao") # no coma
) # Crear un data frame con nombres, edades y ciudades
print(df) # Imprimir el data frame
head(df, 3) # Mostrar las primeras filas del data frame
tail(df) # Mostrar las últimas filas del data frame
tail(df,2) # Mostrar las últimas filas del data frame
df$Nombre # Acceder a la columna Nombre del data frame
#### poner coma a la izquierda y a ala derecha
df[, "Nombre"] # Acceder a la columna Nombre del data frame (otra forma)
df[["Nombre"]] # Acceder a la columna Nombre del data frame (otra forma)
df$Edad # Acceder a la columna Edad del data frame
df$Edad # Acceder a la columna Edad del data frame
df$Ciudad # Acceder a la columna Ciudad del data frame
a <- df$Nombre # Asignar la columna Nombre a la variable a
print(a) # Imprimir la variable a
df$Telefono <- c("123456789", "987654321", "456123789", "789456123", "321654987") # Agregar una nueva columna Teléfono al data frame
print(df) # Imprimir el data frame actualizado
df[, c("Nombre", "Ciudad")] # Acceder a las columnas Nombre y Ciudad del data frame
df[, c(1,2)] # Acceder a las dos primeras columnas del data frame
df$Edad > 30
df[df$Edad > 30, ] # Filtrar filas donde la Edad es mayor a 30
m <- as.matrix(data.frame(col1 = c(1,2,3), col2 = c(4,5,6))) # Crear una matriz a partir de un data frame
print(m) # Imprimir la matriz
data <- data.frame(col1 = c(1,2,3), col2 = c(4,5,6))
print(data)
m <- as.matrix(data) # Crear una matriz a partir de un data frame
print(m) # Imprimir la matriz
## Factores (Categorías)
# Son variables de texto que representan categorías fijas (niveles). Útiles para clasificar datos, como "Pequeño/Mediano/Grande".
grupos <- c("Control", "Tratado", "Control", "Tratado")
## Factores (Categorías)
# Son variables de texto que representan categorías fijas (niveles). Útiles para clasificar datos, como "Pequeño/Mediano/Grande".
grupos <- c("Control", "Tratamiento", "Control", "Tratamiento")
grupos_factor <- factor(grupos)
print(grupos_factor) # Fíjate en los "Levels" (Niveles)
## Factores (Categorías)
# Son variables de texto que representan categorías fijas (niveles). Útiles para clasificar datos, como "Pequeño/Mediano/Grande".
grupos <- c("Control", "Tratamiento", "Control", "Tratamiento", "Lechuga")
grupos_factor <- factor(grupos)
print(grupos_factor) # Fíjate en los "Levels" (Niveles)
levels(grupos_factor) # Muestra las categorías únicas
## Factores (Categorías)
# Son variables de texto que representan categorías fijas (niveles). Útiles para clasificar datos, como "Pequeño/Mediano/Grande".
grupos <- c("Control", "Tratamiento", "Control", "Tratamiento")
grupos_factor <- factor(grupos)
print(grupos_factor) # Fíjate en los "Levels" (Niveles)
levels(grupos_factor) # Muestra las categorías únicas
## Listas (El contenedor universal)
# El "cajón de sastre". Puede contener objetos de cualquier tipo y tamaño: un número, un vector y un dataframe, todo dentro de la misma lista.
mi_lista <- list(
id_muestra = "S001",
mediciones = c(1.2, 3.4, 5.6),
es_valido = TRUE,
datos_tabla = df[1:2, ] # Podemos meter hasta un trozo de Data Frame
)
print(mi_lista)
mi_lista$id_muestra  # Acceder por nombre (igual que en Data Frames)
mi_lista[[2]]
print("Hola Mundo")
print("Hola Mundo")
setwd()
getwd()
setwd("~/GitHub/bioinfo_stuffs")
## Booleano (Verdadero o Falso)
# Se llaman "logical". Son el resultado de comparaciones. Tiene solo dos opciones: TRUE o FALSE
TRUE
FALSE
# Operadores Lógicos Aplicados a números
# Comparan magnitudes y devuelven un booleano.
10 > 5   # Mayor que
10 >= # Mayor o igual que
10 < 5   # Menor que
10 >= 5  # Mayor o igual que
10 < 5   # Menor que
10 <= 5 # Menor o igual que
10 == 10 # IGUAL A (se usan dos signos para no confundir con asignación)
10 != 9  # DISTINTO DE
# uso de !
# al poner ! antes de una operación lógica, invierte el resultado
10 > 5 # TRUE
!10 > 5 # FALSE
!10 < 5
## Factores (Categorías) -> se usa la función factor()
# Son datos que parecen texto pero representan niveles o grupos definidos.
factor("Hombre")
## Vectores (Conjunto de datos de una dimensión) -> se asignan con c()
# Es una lista simple de elementos
c(1, 2, 3, 4, 5)          # Vector numérico
c("Azul", "Rojo", "Verde") # Vector de texto
c(TRUE, FALSE, FALSE) # Vector booleano
c(1,"Azul",TRUE") # Vector mixto
!
!
""
c(1,"Azul",TRUE) # Vector mixto
